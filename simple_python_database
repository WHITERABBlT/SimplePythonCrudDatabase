from dataclasses import dataclass
from typing import Optional, List, Dict, Any

@dataclass
class Employee:
    """Data model representing an employee."""
    id: int
    name: str
    age: int
    position: str

# In-memory storage for employees
employees: List[Employee] = []

def _get_employee_by_id(emp_id: int) -> Optional[Employee]:
    """Internal helper to find an employee by ID.

    Args:
        emp_id: The unique identifier of the employee.

    Returns:
        The Employee instance if found, otherwise None.
    """
    for emp in employees:
        if emp.id == emp_id:
            return emp
    return None

def create_employee(id: int, name: str, age: int, position: str) -> Employee:
    """Create and store a new employee.

    Raises:
        ValueError: If an employee with the given ID already exists.
    """
    if _get_employee_by_id(id) is not None:
        raise ValueError(f"Employee with id {id} already exists.")

    emp = Employee(id=id, name=name, age=age, position=position)
    employees.append(emp)
    return emp

def read_employee(id: int) -> Optional[Employee]:
    """Read (retrieve) an employee by ID.

    Returns:
        The Employee instance if found, otherwise None.
    """
    return _get_employee_by_id(id)

def update_employee(id: int, updated_data: Dict[str, Any]) -> Optional[Employee]:
    """Update fields of an existing employee using a dict of updates.

    Only known fields are updated. The function will raise if an attempt is
    made to change the immutable 'id' field.

    Args:
        id: The ID of the employee to update.
        updated_data: A dictionary of fields to update (e.g., {"name": "New Name"}).

    Returns:
        The updated Employee instance, or None if the employee does not exist.
    """
    emp = _get_employee_by_id(id)
    if emp is None:
        return None

    allowed = {"name", "age", "position"}
    for key, value in updated_data.items():
        if key in allowed:
            setattr(emp, key, value)
        elif key == "id":
            # Do not allow updating the primary key
            raise ValueError("Cannot update the 'id' of an existing employee.")
        else:
            # Ignore unknown keys (could also log a warning)
            pass
    return emp

def delete_employee(id: int) -> bool:
    """Delete the employee with the given ID.

    Returns:
        True if an employee was deleted, False if not found.
    """
    global employees
    before = len(employees)
    employees = [emp for emp in employees if emp.id != id]
    return len(employees) < before

if __name__ == "__main__":
    # Simple usage example
    try:
        e1 = create_employee(1, "Alice", 30, "Engineer")
        e2 = create_employee(2, "Bob", 28, "Designer")
        print("Created:", e1, e2)

        print("Read 1:", read_employee(1))

        update_employee(1, {"age": 31, "position": "Senior Engineer"})
        print("After update 1:", read_employee(1))

        delete_employee(2)
        print("All employees:", employees)
    except Exception as ex:
        print("Error:", ex)
